#!/usr/bin/env bash
# dotty - a dotfiles manager with overlay semantics

set -euo pipefail

DOTTY_VERSION="0.1.0"
DOTTY_DIR="${DOTTY_DIR:-$HOME/.dotty}"
DOTTY_REGISTRY="$DOTTY_DIR/registry"
DOTTY_REPOS_DIR="$DOTTY_DIR/repos"
DOTTY_BACKUPS_DIR="$DOTTY_DIR/backups"
DOTTY_VERBOSE="${DOTTY_VERBOSE:-false}"

# shellcheck source=lib/utils.sh
source "$(cd "$(dirname "$0")" && pwd)/lib/utils.sh"

# --- Registry

registry_init() {
    mkdir -p "$DOTTY_DIR" "$DOTTY_REPOS_DIR" "$DOTTY_BACKUPS_DIR"
    touch "$DOTTY_REGISTRY"
}

registry_get() {
    local name="$1"
    grep -m1 "^${name}=" "$DOTTY_REGISTRY" 2>/dev/null | cut -d= -f2-
}

registry_set() {
    local name="$1"
    local path="$2"

    if grep -q "^${name}=" "$DOTTY_REGISTRY" 2>/dev/null; then
        # Update existing entry (portable sed)
        local tmp="$DOTTY_REGISTRY.tmp"
        grep -v "^${name}=" "$DOTTY_REGISTRY" > "$tmp" || true
        echo "${name}=${path}" >> "$tmp"
        mv "$tmp" "$DOTTY_REGISTRY"
    else
        echo "${name}=${path}" >> "$DOTTY_REGISTRY"
    fi
}

registry_remove() {
    local name="$1"
    local tmp="$DOTTY_REGISTRY.tmp"
    grep -v "^${name}=" "$DOTTY_REGISTRY" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$DOTTY_REGISTRY"
}

registry_names() {
    cut -d= -f1 "$DOTTY_REGISTRY" 2>/dev/null
}

# --- Config reading

# Sets: DOTTY_NAME, DOTTY_EXTENDS, DOTTY_ENVIRONMENTS, DOTTY_ENV_DETECT
read_config() {
    local repo_dir="$1"
    local conf="$repo_dir/dotty.conf"

    [[ -f "$conf" ]] || die "No dotty.conf found in $repo_dir"

    DOTTY_NAME=""
    DOTTY_EXTENDS=()
    DOTTY_ENVIRONMENTS=()
    DOTTY_ENV_DETECT=""

    # shellcheck disable=SC1090
    source "$conf"

    [[ -n "$DOTTY_NAME" ]] || die "DOTTY_NAME is required in $conf"
}

# --- Chain resolution

CHAIN_NAMES=()
CHAIN_PATHS=()
_RESOLVING=()

resolve_chain() {
    local repo_dir
    repo_dir="$(cd "$1" && pwd)"

    read_config "$repo_dir"
    local name="$DOTTY_NAME"
    local -a extends=("${DOTTY_EXTENDS[@]}")

    # Cycle detection
    for r in "${_RESOLVING[@]}"; do
        [[ "$r" == "$name" ]] && die "Dependency cycle detected: $name"
    done
    _RESOLVING+=("$name")

    # Resolve parents first (so base repos come first in chain)
    for parent_url in "${extends[@]}"; do
        local parent_dir
        parent_dir="$(ensure_repo "$parent_url")"
        resolve_chain "$parent_dir"
    done

    # Add self (skip if already in chain, e.g. diamond dependency)
    for existing in "${CHAIN_NAMES[@]}"; do
        [[ "$existing" == "$name" ]] && return 0
    done

    CHAIN_NAMES+=("$name")
    CHAIN_PATHS+=("$repo_dir")
}

resolve_chain_from_leaf() {
    registry_init

    local -a all_paths=()
    while IFS='=' read -r name rpath; do
        [[ -n "$name" && -d "$rpath" ]] && all_paths+=("$rpath")
    done < "$DOTTY_REGISTRY"

    [[ ${#all_paths[@]} -gt 0 ]] || die "No repos registered. Run 'dotty install' first."

    local best_len=0
    local -a best_names=() best_paths=()
    for rpath in "${all_paths[@]}"; do
        [[ -f "$rpath/dotty.conf" ]] || continue
        CHAIN_NAMES=()
        CHAIN_PATHS=()
        _RESOLVING=()
        resolve_chain "$rpath" 2>/dev/null || true
        if [[ ${#CHAIN_NAMES[@]} -gt $best_len ]]; then
            best_len=${#CHAIN_NAMES[@]}
            best_names=("${CHAIN_NAMES[@]}")
            best_paths=("${CHAIN_PATHS[@]}")
        fi
    done
    CHAIN_NAMES=("${best_names[@]}")
    CHAIN_PATHS=("${best_paths[@]}")
}

ensure_repo() {
    local source="$1"

    if [[ -d "$source" ]]; then
        (cd "$source" && pwd)
        return 0
    fi

    # Check registry — the repo name often matches the URL basename
    local url_basename
    url_basename="$(basename "$source" .git)"
    local registered_path
    registered_path="$(registry_get "$url_basename")"
    if [[ -n "$registered_path" && -d "$registered_path" && -f "$registered_path/dotty.conf" ]]; then
        echo "$registered_path"
        return 0
    fi

    # Check if already cloned in DOTTY_REPOS_DIR
    for dir in "$DOTTY_REPOS_DIR"/*/; do
        [[ -d "$dir" ]] || continue
        if [[ -f "$dir/dotty.conf" ]]; then
            local found_name
            found_name="$(DOTTY_NAME=""; DOTTY_EXTENDS=(); DOTTY_ENVIRONMENTS=(); DOTTY_ENV_DETECT=""; source "$dir/dotty.conf"; echo "$DOTTY_NAME")"
            if [[ -n "$found_name" ]]; then
                local found_path
                found_path="$(registry_get "$found_name")"
                if [[ -n "$found_path" && -d "$found_path" ]]; then
                    echo "$found_path"
                    return 0
                fi
            fi
        fi
    done

    local clone_name
    clone_name="$(basename "$source" .git)"
    local clone_dir="$DOTTY_REPOS_DIR/$clone_name"

    if [[ -d "$clone_dir" ]]; then
        echo "$clone_dir"
        return 0
    fi

    info "Cloning $source..." >&2
    git clone "$source" "$clone_dir" >&2 || die "Failed to clone $source"

    # Read its name and register
    if [[ -f "$clone_dir/dotty.conf" ]]; then
        local cloned_name
        cloned_name="$(DOTTY_NAME=""; DOTTY_EXTENDS=(); DOTTY_ENVIRONMENTS=(); DOTTY_ENV_DETECT=""; source "$clone_dir/dotty.conf"; echo "$DOTTY_NAME")"
        if [[ -n "$cloned_name" ]]; then
            registry_set "$cloned_name" "$clone_dir"
        fi
    fi

    echo "$clone_dir"
}

# --- Environment detection

detect_environment() {
    local i
    for (( i=${#CHAIN_PATHS[@]}-1; i>=0; i-- )); do
        local dir="${CHAIN_PATHS[$i]}"
        local env_detect
        env_detect="$(DOTTY_ENV_DETECT=""; DOTTY_EXTENDS=(); DOTTY_ENVIRONMENTS=(); source "$dir/dotty.conf"; echo "$DOTTY_ENV_DETECT")"
        if [[ -n "$env_detect" ]]; then
            local detected
            detected="$(eval "$env_detect")"
            if [[ -n "$detected" ]]; then
                echo "$detected"
                return 0
            fi
        fi
    done
}

# --- Core operations

pull_if_clean() {
    local dir="$1"
    if [[ ! -d "$dir/.git" ]]; then
        return 0
    fi

    if (cd "$dir" && git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null); then
        info "Pulling $(basename "$dir")..."
        (cd "$dir" && git pull --ff-only 2>/dev/null) || warning "Failed to pull $(basename "$dir")"
    else
        warning "$(basename "$dir") has uncommitted changes, skipping pull."
    fi
}

process_repo() {
    local repo_dir="$1"
    local env="${2:-}"
    local command="${3:-}"

    read_config "$repo_dir"
    local name="$DOTTY_NAME"

    title "Processing $name"

    # Symlink home/ → $HOME
    if [[ -d "$repo_dir/home" ]]; then
        info "Linking home/"
        create_symlinks_from_dir "$repo_dir/home" "$HOME"
    fi

    # Environment overlay: $env/home/ → $HOME
    if [[ -n "$env" && -d "$repo_dir/$env/home" ]]; then
        info "Linking $env/home/ overlay"
        create_symlinks_from_dir "$repo_dir/$env/home" "$HOME"
    fi

    # Run hook (non-fatal so later repos still process).
    # Hooks are skipped during "link" (symlink-only mode).
    if [[ "$command" != "link" ]]; then
        if [[ -x "$repo_dir/dotty-run.sh" ]]; then
            info "Running dotty-run.sh"
            (
                export DOTTY_REPO_DIR="$repo_dir"
                export DOTTY_ENV="${env:-}"
                export DOTTY_COMMAND="${command:-}"
                export DOTTY_VERBOSE
                export DOTTY_LIB
                DOTTY_LIB="$(cd "$(dirname "$0")" && pwd)/lib/utils.sh"
                cd "$repo_dir"
                ./dotty-run.sh
            ) || warning "dotty-run.sh failed in $name (exit $?)"
        elif [[ -f "$repo_dir/dotty-run.sh" ]]; then
            warning "dotty-run.sh exists but is not executable in $name"
        fi
    fi
}

run_chain() {
    local pull="${1:-true}"
    local command="${2:-}"
    local env
    env="$(detect_environment)"

    if [[ -n "$env" ]]; then
        info "Detected environment: $env"
        export DOTTY_ENV="$env"
    fi

    # Register all repos first so the registry is complete even if a hook fails.
    local i
    for (( i=0; i<${#CHAIN_PATHS[@]}; i++ )); do
        registry_set "${CHAIN_NAMES[$i]}" "${CHAIN_PATHS[$i]}"
    done

    for (( i=0; i<${#CHAIN_PATHS[@]}; i++ )); do
        local dir="${CHAIN_PATHS[$i]}"

        if [[ "$pull" == "true" ]]; then
            pull_if_clean "$dir"
        fi

        process_repo "$dir" "$env" "$command"
    done
}

# --- Commands

cmd_install() {
    local source="${1:-}"

    registry_init

    if [[ -z "$source" ]]; then
        # No argument: re-run install on existing repos
        resolve_chain_from_leaf
        run_chain "true" "install"
    else
        local repo_dir
        if [[ -d "$source" ]]; then
            repo_dir="$(cd "$source" && pwd)"
        else
            repo_dir="$(ensure_repo "$source")"
        fi

        # Resolve full chain
        CHAIN_NAMES=()
        CHAIN_PATHS=()
        _RESOLVING=()
        resolve_chain "$repo_dir"

        run_chain "true" "install"
    fi

    success "Install complete!"
    cmd_status
}

cmd_update() {
    local target="${1:-}"

    registry_init

    if [[ -n "$target" ]]; then
        # Update a single repo, but re-run full chain
        local path
        path="$(registry_get "$target")"
        [[ -n "$path" ]] || die "Unknown repo: $target"
        [[ -d "$path" ]] || die "Repo directory not found: $path"

        pull_if_clean "$path"

        # Resolve full chain from the leaf repo
        resolve_chain_from_leaf
        run_chain "false" "update"
    else
        resolve_chain_from_leaf
        run_chain "true" "update"
    fi

    success "Update complete!"
}

cmd_link() {
    local target="${1:-}"

    registry_init

    if [[ -n "$target" ]]; then
        local path
        path="$(registry_get "$target")"
        [[ -n "$path" ]] || die "Unknown repo: $target"

        CHAIN_NAMES=()
        CHAIN_PATHS=()
        _RESOLVING=()
        resolve_chain "$path"
    else
        resolve_chain_from_leaf
    fi

    local env
    env="$(detect_environment)"
    [[ -n "$env" ]] && info "Detected environment: $env"

    local i
    for (( i=0; i<${#CHAIN_PATHS[@]}; i++ )); do
        local dir="${CHAIN_PATHS[$i]}"
        process_repo "$dir" "$env" "link"
    done

    success "Linking complete!"
}

cmd_add() {
    local file=""
    local repo_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repo)
                repo_name="$2"
                shift 2
                ;;
            --repo=*)
                repo_name="${1#--repo=}"
                shift
                ;;
            *)
                file="$1"
                shift
                ;;
        esac
    done

    [[ -n "$file" ]] || die "Usage: dotty add <file> [--repo <name>]"
    [[ -e "$file" ]] || die "File not found: $file"
    [[ -L "$file" ]] && die "Already a symlink: $file"

    registry_init

    local abs_file
    abs_file="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"

    local repo_path=""
    if [[ -n "$repo_name" ]]; then
        repo_path="$(registry_get "$repo_name")"
        [[ -n "$repo_path" ]] || die "Unknown repo: $repo_name"
    else
        local count
        count="$(wc -l < "$DOTTY_REGISTRY" | tr -d ' ')"

        if [[ "$count" -eq 0 ]]; then
            die "No repos registered. Run 'dotty install' first."
        elif [[ "$count" -eq 1 ]]; then
            repo_name="$(cut -d= -f1 "$DOTTY_REGISTRY")"
            repo_path="$(cut -d= -f2- "$DOTTY_REGISTRY")"
        else
            echo "Multiple repos registered. Which one?"
            local i=1
            while IFS='=' read -r name rpath; do
                echo "  $i) $name ($rpath)"
                i=$((i + 1))
            done < "$DOTTY_REGISTRY"
            echo -n "Choice: "
            read -r choice
            repo_name="$(sed -n "${choice}p" "$DOTTY_REGISTRY" | cut -d= -f1)"
            repo_path="$(sed -n "${choice}p" "$DOTTY_REGISTRY" | cut -d= -f2-)"
        fi
    fi

    [[ -d "$repo_path" ]] || die "Repo directory not found: $repo_path"

    local rel_path="${abs_file#"$HOME"/}"
    [[ "$rel_path" != "$abs_file" ]] || die "File must be under \$HOME: $abs_file"
    local dest="$repo_path/home/$rel_path"

    mkdir -p "$(dirname "$dest")"
    mv "$abs_file" "$dest"
    ln -s "$dest" "$abs_file"

    success "Moved: ~/$rel_path → $repo_name/home/$rel_path"
    success "Linked: ~/$rel_path"
    echo ""
    info "Don't forget to commit the new file:"
    echo -e "  ${COLOR_DIM}cd $repo_path && git add home/$rel_path${COLOR_NONE}"
}

cmd_status() {
    registry_init

    title "dotty status"

    local count=0
    local repos=()
    while IFS='=' read -r name rpath; do
        [[ -n "$name" ]] || continue
        repos+=("$name=$rpath")
        count=$((count + 1))
    done < "$DOTTY_REGISTRY"

    if [[ $count -eq 0 ]]; then
        info "No repos registered."
        return 0
    fi

    resolve_chain_from_leaf

    if [[ ${#CHAIN_NAMES[@]} -gt 0 ]]; then
        local chain_str=""
        for (( i=0; i<${#CHAIN_NAMES[@]}; i++ )); do
            [[ -n "$chain_str" ]] && chain_str+=" → "
            chain_str+="${CHAIN_NAMES[$i]}"
        done
        echo -e "  Chain: ${COLOR_GREEN}$chain_str${COLOR_NONE}"
    fi

    local env=""
    if [[ ${#CHAIN_PATHS[@]} -gt 0 ]]; then
        env="$(detect_environment 2>/dev/null)" || true
    fi
    if [[ -n "$env" ]]; then
        echo -e "  Env:   ${COLOR_GREEN}$env${COLOR_NONE}"
    fi

    echo ""

    for entry in "${repos[@]}"; do
        local name="${entry%%=*}"
        local rpath="${entry#*=}"

        local status_icon="?"
        local status_text="unknown"
        if [[ -d "$rpath/.git" ]]; then
            if (cd "$rpath" && git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null); then
                status_icon="${COLOR_GREEN}✓${COLOR_NONE}"
                status_text="clean"
            else
                status_icon="${COLOR_YELLOW}●${COLOR_NONE}"
                status_text="modified"
            fi
        elif [[ -d "$rpath" ]]; then
            status_icon="${COLOR_DIM}-${COLOR_NONE}"
            status_text="not a git repo"
        else
            status_icon="${COLOR_RED}✗${COLOR_NONE}"
            status_text="missing"
        fi

        echo -e "  $status_icon $name ${COLOR_DIM}($rpath) [$status_text]${COLOR_NONE}"
    done
}

cmd_register() {
    local path="${1:-}"
    local name="${2:-}"

    [[ -n "$path" ]] || die "Usage: dotty register <path> [name]"

    registry_init

    [[ -d "$path" ]] || die "Directory not found: $path"
    path="$(cd "$path" && pwd)"

    if [[ -z "$name" ]]; then
        [[ -f "$path/dotty.conf" ]] || die "No dotty.conf found and no name provided"
        name="$(DOTTY_NAME=""; source "$path/dotty.conf"; echo "$DOTTY_NAME")"
        [[ -n "$name" ]] || die "DOTTY_NAME not set in $path/dotty.conf"
    fi

    registry_set "$name" "$path"
    success "Registered $name → $path"
}

cmd_unregister() {
    local name="${1:-}"
    [[ -n "$name" ]] || die "Usage: dotty unregister <name>"

    registry_init

    local path
    path="$(registry_get "$name")"
    [[ -n "$path" ]] || die "Unknown repo: $name"

    registry_remove "$name"
    success "Unregistered $name"
}

cmd_help() {
    cat <<'EOF'
dotty - a dotfiles manager with overlay semantics

Usage: dotty [-v] <command> [args]

Commands:
  install [url-or-path]   Resolve chain, clone deps, link files, run dotty-run.sh
  update [name]           Pull all repos (or one), re-link, re-run dotty-run.sh
  add <file> [--repo X]   Move a dotfile into a repo and symlink it back
  link [name]             Re-create symlinks only (skip pull and hooks)
  status                  Show repos, chain order, and detected environment
  register <path> [name]  Register an already-cloned repo
  unregister <name>       Remove a repo from the registry
  help                    Show this help
  version                 Show version

Options:
  -v, --verbose    Show per-file skip messages (default: summary only)

Hook environment:
  DOTTY_REPO_DIR   Absolute path to the repo being processed
  DOTTY_ENV        Detected environment (empty if none)
  DOTTY_COMMAND    Command that invoked the hook (install, update)
  DOTTY_VERBOSE    "true" when -v/--verbose is set
  DOTTY_LIB        Path to hook utility library (source "$DOTTY_LIB")

General:
  DOTTY_DIR        Base directory for dotty state (default: ~/.dotty)
EOF
}

cmd_version() {
    echo "dotty $DOTTY_VERSION"
}

# --- Main dispatch

main() {
    local args=()
    for arg in "$@"; do
        case "$arg" in
            -v|--verbose) DOTTY_VERBOSE=true ;;
            *) args+=("$arg") ;;
        esac
    done
    set -- "${args[@]}"
    export DOTTY_VERBOSE

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        install)      cmd_install "$@" ;;
        update)       cmd_update "$@" ;;
        add)          cmd_add "$@" ;;
        link)         cmd_link "$@" ;;
        status)       cmd_status "$@" ;;
        register)     cmd_register "$@" ;;
        unregister)   cmd_unregister "$@" ;;
        help|--help)  cmd_help ;;
        version|--version) cmd_version ;;
        *)            die "Unknown command: $cmd. Run 'dotty help' for usage." ;;
    esac
}

main "$@"
